<!-- .slide: data-background-transition: "slide" -->

## アルゴリズムについて

2015/07/22  
darai

参考文献：プログラミングコンテスト攻略のためのアルゴリズムとデータ構造（渡部有隆）

---

### 目的

効果的なアルゴリズムを意識することで、以下を実現  
  
1. 引き継ぎ後に（手入れされないことで）バグが生まれるコードをなくす  
2. 後輩からの尊敬を得る  

---

### example

- 10人分のプレイヤーの得点（100点満点）が記録されたデータから、上位3人を得点順に出力  

入力例  
25 36 4 55 71 18 0 71 89 65  
出力例  
89 71 71  

---

### solution

1. 3回探索
配列A[10]に格納 → 最大値を出力 → 取り除き再度最大値を探査
2. ソート後に出力
配列A[10]に格納 → 降順ソート  
3. 各特典毎の人数を数える  
得点pを獲得した人数を配列B[p]に記録 → B[100],B[99]...と出力

---

### メリデメ

1. 3回探索
単純だがsortが使えるなら2が簡潔
2. ソート後に出力
ソートの方法次第で早さが変わる？  
3. 各特典毎の人数を数える  
汎用性があるが、場合によってはメモリを多く消費する

---

### Q1

- 0 から INTMAX の数字がRandomに並んでいる。しかし実際にはある整数Nが抜けている(総数はINTMAX - 1)。  
Nを調べなさい。   

メモリ制限: 1GB  
時間制限: なし 

---

### Hint

- 0 to INTMAX-1の配列を持とうとすると、必要なメモリは  
2^31 * 4byte / 1024 / 1024 / 1024 = 8Gbyte

- exの解3のように一つずつ調べていく方法だとメモリ制限に引っかかる。

---

### A1

1. 数字一つを表す方法を、int(4byte)より小さくする
2. 合計値は不変なので、ループの中でSum(合計)だけを保持する  

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main(void)
{
    FILE *fp;
    char s[INTMAX - 1];
    unsigned long long sum_real = 0;
    unsigned long long sum_ideal = 15; /* ??=0からINTMAXの和 */
    fp = fopen("q1.txt", "r");
    while (fgets(s, INTMAX - 1, fp) != NULL) {
      s[strlen(s) - 1] = '\0';
      sum_real += atoi( s );
    }
    fclose(fp);
    /* unsigned long long から int への変換 */
    printf("ans=%d\n", sum_ideal - sum_real);
    return 0;
}
```

---

## ビット配列

- 2^31 * 1bit / 1024 / 1024 / 1024 = 0.25Gbyte  
例）0−7の数字だったら、以下のように8桁のビット列を定義する。  

```
0 = 00000000
1 = 00000001
2 = 00000010
8 = 10000000
```

---

## Q1解2

- (INTMAX = 8として)特定の値がきたら、そのビット番目の値に1が立っているビット列とORを取る。  

```
・3がきたら
00000000 OR 00000100 = 00000100
・続いて5がきたら
00000100 OR 00100000 = 00100100
```

---

### Q1改

- 0 から INTMAX の数字が**何度か重複して**Randomに並んでいる。しかし実際にはある整数Nが抜けている(総数はINTMAX - 1)。  
Nを調べなさい。   

メモリ制限: 1GB  
時間制限: なし 

---

### Q2

- 0 から INTMAX の数字が**何度か重複して**Randomに並んでいる。しかし実際にはある整数Nが抜けている(総数はINTMAX - 1)。  
Nを調べなさい。   

メモリ制限: 1MB  
時間制限: なし 

---

### A2

- 1回ループで完結させようとするとビット配列内に0 to INTMAX全てを常に保持する必要がある(250MB)  
- N回ループとし、一回目のループではビット配列内に0 to INTMAX/Nのみ保持し処理。  
ビット配列内に0があればanswer / 全て1なら次のループへ  

処理時間: N倍  
メモリ消費: 250/N MB

---

### Q3(FX取引などでの最大利益)

- ある通貨の価格を時刻tでRtと表現する。利益 Rj - Ri の最大値は？  
(t=0,1,2...,n - 1)(j > i)  

メモリ制限: 65,536KB  
時間制限: 1sec  
制約: 2 ≦ n ≦ 200,000 ; 1 ≦ Rt ≦ 10^9  

---

#### Q3の例

```
入力例1
n=4
5
1
4
2
出力例1
3

入力例1
n=3
4
3
2
出力例1
-1
```

---

#### A3の考え方

```
# 単純だがO(n^2)かかってしまう例
for j 1 to n-1
  for i 1 to j-1
    max = (maxとRj - Ri の大きい方)

# O(n)で終わる例
max = (十分小さな値)
min = (最初の入力)
for j 1 to n-1
  max = (maxとRj - min の大きい方)
  min = (minとRj のうち小さい方)
```

処理時間だけでなく配列も不要なのでメモリ消費も軽減！

---

#### A3解

```
#include <iostream>
#include <algorithm>
using namespace std;
static const int N_MAX = 2000000;

int main()
{
    int R[N_MAX], n;
    cin >> n;
    for ( int i = 0; i < n; i++ ) cin >> R[i];
    
    int max_profit = -1000000;
    int min_r = R[0];
    
    for ( int i = 0; i < n; i++ ) {
        max_profit = max(max_profit, R[i] - min_r);
        min_r = min(min_r, R[i]);
    }
    cout << max_profit << endl;
    
    return 0;
}
```

---

### Q4(ソート)

- バブルソート（順番が逆になっている隣接要素がなくなるまで次の処理を繰り返す）
- 挿入ソート（ソート済みの部分を1つずつ増やしていく）
- 選択的ソート（未ソートの部分から最小の要素を特定し前方へ配置していく）
- シェルソート（一定の間隔gだけ離れた要素のみを対象とした挿入ソートを繰り返す）
- 二分木（既にソート済みなら中央から2分して位置を特定 ex, B-tree-index）

---

### Q5(Stack)

- 一時的にデータを退避したいときに用いる。後入れ先出し。

---

### Q5(Queue)

- ラウンドロビンスケジューリング：CPUがプロセスを順に処理
- 名前Niと処理時間TiをもつN個のプロセスが順番に一列に並んでいる。各プロセスは最大q msだけ処理し、完了しなければそのプロセスは列の最後尾へ移動し次のプロセスへ。  
これをシュミレートせよ

メモリ制限: 65,536KB  
時間制限: 1sec  
制約: 1 ≦ n ≦ 100,000; 1 ≦ q ≦ 1,000; 1 ≦ Ti ≦ 50,000; 1 ≦ Niの長さ≦ 100;

---

#### Q5 ex

```
q=100 
t=0: A(150) - B(80) - C(200) - D(200)
t=100: B(80) - C(200) - D(200) - A(50)
t=180: C(200) - D(200) - A(50)
t=280: D(200) - A(50) - C(100)
```

---


#### Q5の入出力例

```
入力例1
n=4
5
1
4
2
出力例1
3

入力例1
n=3
4
3
2
出力例1
-1
```

---
